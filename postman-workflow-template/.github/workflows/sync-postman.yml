name: Sync Postman Collection

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*-postman.json'
  workflow_dispatch:

jobs:
  sync-postman:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Find Postman Collection
      id: find-collection
      run: |
        COLLECTION=$(find . -name "*-postman.json" | head -1)
        if [ -z "$COLLECTION" ]; then
          echo "‚ùå Nenhuma collection *-postman.json encontrada"
          exit 1
        fi
        echo "collection=$COLLECTION" >> $GITHUB_OUTPUT
        echo "‚úÖ Collection encontrada: $COLLECTION"
        
    - name: Debug Secrets
      run: |
        if [ -z "${{ secrets.POSTMAN_API_KEY }}" ]; then
          echo "‚ùå POSTMAN_API_KEY n√£o configurado nos secrets"
          exit 1
        else
          echo "‚úÖ POSTMAN_API_KEY encontrado"
        fi
        
    - name: Sync Postman Collection
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        COLLECTION_FILE: ${{ steps.find-collection.outputs.collection }}
      run: |
        # Extrai collection ID do arquivo
        COLLECTION_ID=$(jq -r '.info.uid // .info._postman_id' "$COLLECTION_FILE")
        COLLECTION_NAME=$(jq -r '.info.name' "$COLLECTION_FILE")
        
        echo "Collection ID encontrado: $COLLECTION_ID"
        echo "Collection Name: $COLLECTION_NAME"
        
        # Prepara JSON no formato esperado pela API (remove _postman_id customizado)
        jq '{"collection": (. | del(.info._postman_id) | del(.info.uid))}' "$COLLECTION_FILE" > wrapped_collection.json
        
        # Cria nova collection (ID customizado n√£o √© aceito pelo Postman)
        echo "üÜï Criando collection no Postman..."
        
        RESPONSE=$(curl -X POST \
          "https://api.getpostman.com/collections" \
          -H "X-API-Key: $POSTMAN_API_KEY" \
          -H "Content-Type: application/json" \
          -d @wrapped_collection.json \
          --fail-with-body)
        
        NEW_ID=$(echo "$RESPONSE" | jq -r '.collection.id // .collection.uid')
        echo "‚úÖ Collection criada com ID: $NEW_ID"
        echo "üìã COLLECTION_UID: $NEW_ID"
        
        # Atualiza o arquivo local com o novo ID
        jq ".info._postman_id = \"$NEW_ID\"" "$COLLECTION_FILE" > temp.json
        mv temp.json "$COLLECTION_FILE"
        echo "üìù Arquivo local atualizado com novo ID"
        
        # Limpa arquivo tempor√°rio
        rm -f wrapped_collection.json