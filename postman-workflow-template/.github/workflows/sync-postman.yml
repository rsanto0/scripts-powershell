name: Sync Postman Collection

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*-postman.json'
  workflow_dispatch:

jobs:
  sync-postman:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Find Postman Collection
      id: find-collection
      run: |
        COLLECTION=$(find . -name "*-postman.json" | head -1)
        if [ -z "$COLLECTION" ]; then
          echo "‚ùå Nenhuma collection *-postman.json encontrada"
          exit 1
        fi
        echo "collection=$COLLECTION" >> $GITHUB_OUTPUT
        echo "‚úÖ Collection encontrada: $COLLECTION"
        
    - name: Debug Secrets
      run: |
        if [ -z "${{ secrets.POSTMAN_API_KEY }}" ]; then
          echo "‚ùå POSTMAN_API_KEY n√£o configurado nos secrets"
          exit 1
        else
          echo "‚úÖ POSTMAN_API_KEY encontrado"
        fi
        
    - name: Sync Postman Collection
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        COLLECTION_FILE: ${{ steps.find-collection.outputs.collection }}
      run: |
        # Extrai collection ID do arquivo
        COLLECTION_ID=$(jq -r '.info.uid // .info._postman_id' "$COLLECTION_FILE")
        COLLECTION_NAME=$(jq -r '.info.name' "$COLLECTION_FILE")
        
        echo "Collection ID encontrado: $COLLECTION_ID"
        echo "Collection Name: $COLLECTION_NAME"
        
        # Prepara JSON no formato esperado pela API (remove _postman_id customizado)
        jq '{"collection": (. | del(.info._postman_id) | del(.info.uid))}' "$COLLECTION_FILE" > wrapped_collection.json
        
        # Verifica se COLLECTION_UID est√° configurado nos secrets
        if [ -n "${{ secrets.COLLECTION_UID }}" ]; then
          COLLECTION_UID="${{ secrets.COLLECTION_UID }}"
          echo "üìã Usando COLLECTION_UID dos secrets: $COLLECTION_UID"
          
          # Tenta atualizar collection existente
          echo "üìù Tentando atualizar collection existente..."
          if curl -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_UID" \
            -H "X-API-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d @wrapped_collection.json \
            --fail-with-body; then
            echo "‚úÖ Collection atualizada com sucesso!"
          else
            echo "‚ö†Ô∏è Collection n√£o encontrada - criando nova..."
            RESPONSE=$(curl -X POST \
              "https://api.getpostman.com/collections" \
              -H "X-API-Key: $POSTMAN_API_KEY" \
              -H "Content-Type: application/json" \
              -d @wrapped_collection.json \
              --fail-with-body)
            
            NEW_ID=$(echo "$RESPONSE" | jq -r '.collection.id // .collection.uid')
            echo "‚úÖ Nova collection criada com ID: $NEW_ID"
            echo "üìã COLLECTION_UID: $NEW_ID"
            echo "‚ö†Ô∏è Atualize o secret COLLECTION_UID para: $NEW_ID"
          fi
          
        else
          
          # Cria nova collection apenas se COLLECTION_UID n√£o estiver configurado
          echo "üÜï COLLECTION_UID n√£o configurado - criando nova collection..."
          
          RESPONSE=$(curl -X POST \
            "https://api.getpostman.com/collections" \
            -H "X-API-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d @wrapped_collection.json \
            --fail-with-body)
          
          NEW_ID=$(echo "$RESPONSE" | jq -r '.collection.id // .collection.uid')
          echo "‚úÖ Collection criada com ID: $NEW_ID"
          echo "üìã COLLECTION_UID: $NEW_ID"
          echo "‚ö†Ô∏è  Configure este ID como secret COLLECTION_UID para reutilizar"
          
        fi
        
        # Limpa arquivo tempor√°rio
        rm -f wrapped_collection.json